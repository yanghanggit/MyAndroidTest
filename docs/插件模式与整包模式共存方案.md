# 插件模式与整包模式共存方案

## 一、业务场景

### 典型需求

在实际项目中，经常会遇到以下场景：

```text
客户 1（插件模式）：
- 需求：初始包体要小，追求快速安装
- 特点：可以接受首次使用时下载功能模块
- 适用：应用商店分发、网络环境好的用户

客户 2（整包模式）：
- 需求：完整包，所有功能立即可用
- 特点：不希望用户有任何等待和下载过程
- 适用：预装市场、企业内部分发、离线场景
```

### 核心问题

**能否在同一个代码仓库中同时满足两种需求？**

答案：**可以！推荐使用 Build Variants 方案。**

---

## 二、推荐方案：Build Variants（构建变体）

### 核心思路

通过 Gradle 的 Product Flavors 机制，在同一份代码中生成不同的构建产物。

```text
同一代码库
    ↓
不同的构建配置
    ↓
├── Plugin 变体 → 小包（5 MB）+ 运行时下载插件
└── Bundle 变体 → 大包（14 MB）包含所有功能
```

### 优势对比

| 特性 | 单 Repo + Build Variants | 双 Repo（不推荐） |
|------|------------------------|---------|
| **代码维护** | ✅ 统一维护，一次修改 | ❌ 需要同步两份代码 |
| **构建配置** | ✅ 一个构建脚本 | ❌ 两个独立配置 |
| **Bug 修复** | ✅ 修一次即可 | ❌ 需要两边都修 |
| **版本管理** | ✅ 统一版本号 | ⚠️ 需要协调版本 |
| **CI/CD** | ✅ 一个流水线 | ❌ 需要两个流水线 |
| **团队协作** | ✅ 简单直接 | ❌ 需要切换 repo |
| **包体积** | ✅ 可独立优化 | ✅ 可独立优化 |
| **复杂度** | ⚠️ 需要设计抽象层 | ✅ 相对简单 |

---

## 三、技术实现

### 1. 配置 Product Flavors

```kotlin
// app/build.gradle.kts
android {
    compileSdk = 34
    
    defaultConfig {
        applicationId = "com.example.app"
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"
    }
    
    // 定义构建维度
    flavorDimensions += "mode"
    
    productFlavors {
        // 插件模式（小包）
        create("plugin") {
            dimension = "mode"
            applicationIdSuffix = ".plugin"
            versionNameSuffix = "-plugin"
            
            // 构建配置
            buildConfigField("boolean", "IS_PLUGIN_MODE", "true")
            buildConfigField("String", "MODE_NAME", "\"PLUGIN\"")
            
            // 自定义资源值
            resValue("string", "app_mode", "插件版")
        }
        
        // 整包模式（大包）
        create("bundle") {
            dimension = "mode"
            applicationIdSuffix = ".bundle"
            versionNameSuffix = "-bundle"
            
            // 构建配置
            buildConfigField("boolean", "IS_PLUGIN_MODE", "false")
            buildConfigField("String", "MODE_NAME", "\"BUNDLE\"")
            
            // 自定义资源值
            resValue("string", "app_mode", "完整版")
        }
    }
    
    // 源代码目录配置
    sourceSets {
        getByName("main") {
            // 通用代码
        }
        getByName("plugin") {
            // 插件模式专用代码
            java.srcDirs("src/plugin/java")
            res.srcDirs("src/plugin/res")
        }
        getByName("bundle") {
            // 整包模式专用代码
            java.srcDirs("src/bundle/java")
            res.srcDirs("src/bundle/res")
        }
    }
}

dependencies {
    // 通用依赖
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    
    // 插件模式：只包含 Shadow 框架和加载器
    "pluginImplementation"(project(":plugin-loader"))
    "pluginImplementation"("com.tencent.shadow:plugin-loader:2.0.0")
    
    // 整包模式：直接包含所有业务模块
    "bundleImplementation"(project(":business-core"))
    "bundleImplementation"(project(":feature-a"))
    "bundleImplementation"(project(":feature-b"))
    "bundleImplementation"(project(":feature-c"))
}
```

### 2. 应用初始化

```kotlin
// ========== Application 入口 ==========
class MyApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        
        // 根据构建类型初始化
        if (BuildConfig.IS_PLUGIN_MODE) {
            initPluginMode()
        } else {
            initBundleMode()
        }
    }
    
    /**
     * 插件模式初始化
     * - 初始化 Shadow 框架
     * - 配置插件下载器
     * - 预加载核心插件（可选）
     */
    private fun initPluginMode() {
        Log.d("App", "初始化插件模式")
        
        // 初始化 Shadow 插件管理器
        PluginManager.init(this)
        
        // 配置插件服务器地址
        PluginConfig.setServerUrl("https://api.example.com/plugins/")
        
        // 配置插件存储路径
        PluginConfig.setPluginDir(getExternalFilesDir("plugins")?.absolutePath)
        
        // 预加载核心插件（可选）
        preloadCorePlugins()
    }
    
    /**
     * 整包模式初始化
     * - 直接初始化所有业务模块
     * - 无需下载，所有功能立即可用
     */
    private fun initBundleMode() {
        Log.d("App", "初始化整包模式")
        
        // 初始化所有业务模块
        BusinessCore.init(this)
        FeatureA.init(this)
        FeatureB.init(this)
        FeatureC.init(this)
    }
    
    private fun preloadCorePlugins() {
        // 后台预加载首页必需的插件
        PluginPreloader.preload(listOf("home", "login"))
    }
}
```

### 3. 统一的模块加载接口

```kotlin
// ========== 定义统一的模块加载接口 ==========
interface ModuleLoader {
    /**
     * 加载模块
     * @param moduleId 模块ID
     * @param callback 加载完成回调
     */
    fun loadModule(moduleId: String, callback: (Module) -> Unit)
    
    /**
     * 检查模块是否可用
     * @param moduleId 模块ID
     * @return true: 模块可用，false: 需要下载
     */
    fun isModuleAvailable(moduleId: String): Boolean
    
    /**
     * 预加载模块（可选）
     * @param moduleIds 模块ID列表
     */
    fun preloadModules(moduleIds: List<String>)
}

// ========== 业务模块接口 ==========
interface Module {
    fun start(context: Context)
    fun stop()
    fun getMainActivity(): Class<out Activity>?
}
```

### 4. 插件模式实现

```kotlin
// ========== 插件模式的加载器实现 ==========
class PluginModeLoader(private val context: Context) : ModuleLoader {
    
    override fun loadModule(moduleId: String, callback: (Module) -> Unit) {
        // 1. 检查插件是否已安装
        if (PluginManager.isPluginInstalled(moduleId)) {
            // 已下载，直接加载
            loadInstalledPlugin(moduleId, callback)
        } else {
            // 未下载，需要先下载
            downloadAndLoadPlugin(moduleId, callback)
        }
    }
    
    private fun loadInstalledPlugin(moduleId: String, callback: (Module) -> Unit) {
        try {
            val module = PluginManager.loadPlugin(moduleId)
            callback(module)
        } catch (e: Exception) {
            Log.e("PluginLoader", "加载插件失败: $moduleId", e)
            // 可能插件损坏，尝试重新下载
            downloadAndLoadPlugin(moduleId, callback)
        }
    }
    
    private fun downloadAndLoadPlugin(moduleId: String, callback: (Module) -> Unit) {
        // 显示下载进度对话框
        val dialog = ProgressDialog.show(context, "加载中", "正在下载功能模块...")
        
        PluginDownloader.download(moduleId, 
            onProgress = { progress ->
                dialog.setMessage("下载中... ${progress}%")
            },
            onComplete = { success ->
                dialog.dismiss()
                if (success) {
                    loadInstalledPlugin(moduleId, callback)
                } else {
                    showError("下载失败，请检查网络连接")
                }
            }
        )
    }
    
    override fun isModuleAvailable(moduleId: String): Boolean {
        return PluginManager.isPluginInstalled(moduleId)
    }
    
    override fun preloadModules(moduleIds: List<String>) {
        // 后台静默下载
        moduleIds.forEach { moduleId ->
            if (!isModuleAvailable(moduleId)) {
                PluginDownloader.downloadSilently(moduleId)
            }
        }
    }
}
```

### 5. 整包模式实现

```kotlin
// ========== 整包模式的加载器实现 ==========
class BundleModeLoader(private val context: Context) : ModuleLoader {
    
    // 所有模块都已内置，无需下载
    private val moduleMap = mapOf(
        "feature_a" to FeatureAModule(),
        "feature_b" to FeatureBModule(),
        "feature_c" to FeatureCModule(),
        "home" to HomeModule(),
        "profile" to ProfileModule()
    )
    
    override fun loadModule(moduleId: String, callback: (Module) -> Unit) {
        // 整包模式：所有模块立即可用
        val module = moduleMap[moduleId] 
            ?: throw IllegalArgumentException("Unknown module: $moduleId")
        
        // 立即回调，无延迟
        callback(module)
    }
    
    override fun isModuleAvailable(moduleId: String): Boolean {
        // 整包模式：所有模块都可用
        return moduleMap.containsKey(moduleId)
    }
    
    override fun preloadModules(moduleIds: List<String>) {
        // 整包模式：无需预加载，所有模块已加载
        // 可以做一些初始化工作
        moduleIds.forEach { moduleId ->
            moduleMap[moduleId]?.let { module ->
                // 初始化模块
                if (module is Initializable) {
                    module.initialize(context)
                }
            }
        }
    }
}
```

### 6. 工厂类

```kotlin
// ========== 加载器工厂 ==========
object ModuleLoaderFactory {
    
    private var instance: ModuleLoader? = null
    
    fun init(context: Context) {
        instance = create(context)
    }
    
    fun getInstance(): ModuleLoader {
        return instance ?: throw IllegalStateException("ModuleLoader not initialized")
    }
    
    private fun create(context: Context): ModuleLoader {
        return if (BuildConfig.IS_PLUGIN_MODE) {
            PluginModeLoader(context)
        } else {
            BundleModeLoader(context)
        }
    }
}
```

### 7. 业务代码统一调用

```kotlin
// ========== 业务代码无需关心底层实现 ==========
class MainActivity : AppCompatActivity() {
    
    private lateinit var moduleLoader: ModuleLoader
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        moduleLoader = ModuleLoaderFactory.getInstance()
        
        // 显示当前模式
        findViewById<TextView>(R.id.tvMode).text = BuildConfig.MODE_NAME
        
        setupButtons()
    }
    
    private fun setupButtons() {
        // 功能 A
        findViewById<Button>(R.id.btnFeatureA).setOnClickListener {
            openFeature("feature_a")
        }
        
        // 功能 B
        findViewById<Button>(R.id.btnFeatureB).setOnClickListener {
            openFeature("feature_b")
        }
        
        // 个人中心
        findViewById<Button>(R.id.btnProfile).setOnClickListener {
            openFeature("profile")
        }
    }
    
    private fun openFeature(moduleId: String) {
        // 检查模块是否可用
        if (!moduleLoader.isModuleAvailable(moduleId)) {
            // 插件模式：提示需要下载
            showDownloadPrompt(moduleId)
        } else {
            // 直接加载（整包模式立即可用）
            loadAndStart(moduleId)
        }
    }
    
    private fun showDownloadPrompt(moduleId: String) {
        AlertDialog.Builder(this)
            .setTitle("下载功能模块")
            .setMessage("该功能需要下载，是否继续？")
            .setPositiveButton("下载") { _, _ ->
                loadAndStart(moduleId)
            }
            .setNegativeButton("取消", null)
            .show()
    }
    
    private fun loadAndStart(moduleId: String) {
        // 统一的加载方式，兼容两种模式
        moduleLoader.loadModule(moduleId) { module ->
            // 插件模式：可能有下载延迟
            // 整包模式：立即返回
            
            val activityClass = module.getMainActivity()
            if (activityClass != null) {
                startActivity(Intent(this, activityClass))
            } else {
                module.start(this)
            }
        }
    }
}
```

---

## 四、项目结构

### 推荐的目录结构

```text
MyProject/
├── app/                                    # 宿主应用
│   ├── src/
│   │   ├── main/                          # 通用代码（两种模式共用）
│   │   │   ├── java/
│   │   │   │   └── com/example/app/
│   │   │   │       ├── MyApplication.kt   # 应用入口
│   │   │   │       ├── MainActivity.kt    # 主界面
│   │   │   │       └── loader/
│   │   │   │           ├── ModuleLoader.kt
│   │   │   │           └── ModuleLoaderFactory.kt
│   │   │   ├── res/
│   │   │   └── AndroidManifest.xml
│   │   │
│   │   ├── plugin/                        # 插件模式专用代码
│   │   │   ├── java/
│   │   │   │   └── com/example/app/loader/
│   │   │   │       └── PluginModeLoader.kt
│   │   │   └── res/
│   │   │
│   │   └── bundle/                        # 整包模式专用代码
│   │       ├── java/
│   │       │   └── com/example/app/loader/
│   │       │       └── BundleModeLoader.kt
│   │       └── res/
│   │
│   └── build.gradle.kts
│
├── business-core/                          # 业务核心库（共用）
│   ├── src/main/java/
│   │   └── com/example/business/
│   │       ├── Module.kt                  # 模块接口
│   │       └── BaseModule.kt              # 模块基类
│   └── build.gradle.kts
│
├── plugin-loader/                          # Shadow 插件加载器（仅插件模式）
│   ├── src/main/java/
│   │   └── com/example/plugin/
│   │       ├── PluginManager.kt
│   │       ├── PluginDownloader.kt
│   │       └── PluginConfig.kt
│   └── build.gradle.kts
│
├── feature-a/                              # 功能模块 A
│   ├── src/main/
│   │   ├── java/
│   │   │   └── com/example/feature/a/
│   │   │       ├── FeatureAModule.kt
│   │   │       └── FeatureAActivity.kt
│   │   ├── res/
│   │   └── AndroidManifest.xml
│   └── build.gradle.kts
│
├── feature-b/                              # 功能模块 B
│   └── ...
│
├── feature-c/                              # 功能模块 C
│   └── ...
│
├── settings.gradle.kts
└── build.gradle.kts
```

---

## 五、构建和部署

### 1. 构建命令

```bash
# ========== 构建插件模式（小包） ==========
# Debug 版本
./gradlew assemblePluginDebug

# Release 版本
./gradlew assemblePluginRelease

# 输出路径：
# app/build/outputs/apk/plugin/release/app-plugin-release.apk


# ========== 构建整包模式（大包） ==========
# Debug 版本
./gradlew assembleBundleDebug

# Release 版本
./gradlew assembleBundleRelease

# 输出路径：
# app/build/outputs/apk/bundle/release/app-bundle-release.apk


# ========== 同时构建两种模式 ==========
./gradlew assemble

# 输出两个 APK：
# - app-plugin-release.apk
# - app-bundle-release.apk
```

### 2. 安装和测试

```bash
# 安装插件模式
./gradlew installPluginDebug
adb shell am start -n com.example.app.plugin/.MainActivity

# 安装整包模式
./gradlew installBundleDebug
adb shell am start -n com.example.app.bundle/.MainActivity

# 卸载
adb uninstall com.example.app.plugin
adb uninstall com.example.app.bundle
```

### 3. 包体积对比

```text
实际案例（电商 APP）：

插件模式 APK：
├── app-plugin-release.apk           5 MB
│   └── 包含：
│       ├── 宿主框架                  2 MB
│       ├── Shadow 框架              1 MB
│       ├── 首页模块                  1.5 MB
│       └── 登录模块                  0.5 MB
│
└── 插件文件（运行时按需下载）:
    ├── feature-product.apk          2 MB    （商品详情）
    ├── feature-cart.apk             1.5 MB  （购物车）
    ├── feature-order.apk            2.5 MB  （订单管理）
    └── feature-profile.apk          1 MB    （个人中心）
    
    总计：5 MB (初始) + 7 MB (按需) = 12 MB

整包模式 APK：
└── app-bundle-release.apk           14 MB
    └── 包含所有功能，一次性下载

用户体验：
- 插件模式：初次安装快（5 MB），首次使用某功能需等待下载
- 整包模式：初次安装慢（14 MB），所有功能立即可用
```

---

## 六、CI/CD 配置

### GitHub Actions 示例

```yaml
# .github/workflows/build.yml
name: Build APKs

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        distribution: 'temurin'
        java-version: '17'
        cache: 'gradle'
    
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    
    # 构建插件模式
    - name: Build Plugin APK
      run: ./gradlew assemblePluginRelease
    
    # 构建整包模式
    - name: Build Bundle APK
      run: ./gradlew assembleBundleRelease
    
    # 构建插件文件（如果需要）
    - name: Build Plugin Modules
      run: |
        ./gradlew :feature-a:assembleRelease
        ./gradlew :feature-b:assembleRelease
        ./gradlew :feature-c:assembleRelease
    
    # 上传产物
    - name: Upload Plugin APK
      uses: actions/upload-artifact@v3
      with:
        name: app-plugin-release
        path: app/build/outputs/apk/plugin/release/app-plugin-release.apk
    
    - name: Upload Bundle APK
      uses: actions/upload-artifact@v3
      with:
        name: app-bundle-release
        path: app/build/outputs/apk/bundle/release/app-bundle-release.apk
    
    - name: Upload Plugin Modules
      uses: actions/upload-artifact@v3
      with:
        name: plugin-modules
        path: |
          feature-a/build/outputs/apk/release/*.apk
          feature-b/build/outputs/apk/release/*.apk
          feature-c/build/outputs/apk/release/*.apk
    
    # 生成构建报告
    - name: Generate Build Report
      run: |
        echo "## Build Report" > build-report.md
        echo "" >> build-report.md
        echo "### APK Sizes" >> build-report.md
        echo "- Plugin Mode: $(ls -lh app/build/outputs/apk/plugin/release/app-plugin-release.apk | awk '{print $5}')" >> build-report.md
        echo "- Bundle Mode: $(ls -lh app/build/outputs/apk/bundle/release/app-bundle-release.apk | awk '{print $5}')" >> build-report.md
    
    - name: Comment PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const report = fs.readFileSync('build-report.md', 'utf8');
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: report
          });
```

---

## 七、最佳实践

### 1. 模块划分原则

```kotlin
/**
 * 模块划分建议：
 * 
 * 核心模块（必须内置）：
 * - 首页
 * - 登录/注册
 * - 基础框架
 * 
 * 可选模块（可按需加载）：
 * - 商品详情
 * - 购物车
 * - 订单管理
 * - 个人中心
 * - 消息通知
 * 
 * 低频模块（建议按需加载）：
 * - 设置
 * - 帮助中心
 * - 关于我们
 */
```

### 2. 预加载策略

```kotlin
class SmartPreloader(private val context: Context) {
    
    fun preloadIntelligently() {
        // 1. WiFi 环境下预加载所有常用模块
        if (isWiFiConnected()) {
            preloadAllFrequentModules()
        }
        
        // 2. 根据用户使用习惯预加载
        val frequentModules = getUserFrequentModules()
        ModuleLoaderFactory.getInstance().preloadModules(frequentModules)
        
        // 3. 空闲时预加载
        IdleHandler.runOnIdle {
            preloadLowPriorityModules()
        }
    }
    
    private fun isWiFiConnected(): Boolean {
        val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = cm.activeNetwork ?: return false
        val capabilities = cm.getNetworkCapabilities(network) ?: return false
        return capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
    }
}
```

### 3. 缓存和版本管理

```kotlin
class PluginVersionManager {
    
    /**
     * 检查插件更新
     */
    fun checkUpdates() {
        val localPlugins = PluginManager.getInstalledPlugins()
        
        // 从服务器获取最新版本信息
        ApiClient.getPluginVersions { remoteVersions ->
            localPlugins.forEach { plugin ->
                val remoteVersion = remoteVersions[plugin.id]
                if (remoteVersion != null && remoteVersion > plugin.version) {
                    // 发现新版本，提示更新
                    notifyUpdate(plugin.id, remoteVersion)
                }
            }
        }
    }
    
    /**
     * 清理过期插件
     */
    fun cleanupOldPlugins() {
        val plugins = PluginManager.getInstalledPlugins()
        plugins.forEach { plugin ->
            if (isPluginExpired(plugin)) {
                PluginManager.uninstallPlugin(plugin.id)
            }
        }
    }
}
```

### 4. 降级策略

```kotlin
class GracefulDegradation {
    
    /**
     * 优雅降级：插件加载失败时的处理
     */
    fun handlePluginLoadFailure(moduleId: String) {
        when {
            // 网络问题
            !isNetworkAvailable() -> {
                showToast("网络不可用，请检查网络连接")
                // 提供离线功能或缓存内容
                showOfflineContent(moduleId)
            }
            
            // 存储空间不足
            !hasEnoughStorage() -> {
                showToast("存储空间不足，请清理后重试")
                // 引导用户清理
                openStorageSettings()
            }
            
            // 下载失败
            else -> {
                // 重试机制
                showRetryDialog(moduleId)
            }
        }
    }
}
```

---

## 八、常见问题

### Q1: 两种模式的包名能相同吗？

**答**：不建议相同。建议使用不同的 `applicationIdSuffix`：

```kotlin
productFlavors {
    create("plugin") {
        applicationIdSuffix = ".plugin"  // com.example.app.plugin
    }
    create("bundle") {
        applicationIdSuffix = ".bundle"  // com.example.app.bundle
    }
}
```

这样可以在同一设备上同时安装两个版本，方便测试对比。

### Q2: 如何处理数据迁移？

```kotlin
class DataMigration {
    fun migrateIfNeeded() {
        val oldPackage = "com.example.app.plugin"
        val currentPackage = context.packageName
        
        if (currentPackage != oldPackage && hasOldData(oldPackage)) {
            // 从旧包迁移数据
            migrateData(from = oldPackage, to = currentPackage)
        }
    }
}
```

### Q3: 插件模式的权限问题？

**答**：插件需要的所有权限都必须在宿主 APK 的 Manifest 中声明。详见《插件化中的AndroidManifest处理方案.md》。

### Q4: 性能差异大吗？

```text
启动速度：
- 插件模式：略慢（需要初始化 Shadow 框架）+50ms
- 整包模式：略快（直接初始化）

内存占用：
- 插件模式：较低（按需加载）
- 整包模式：较高（所有模块已加载）

功能响应：
- 插件模式：首次使用有延迟（下载时间）
- 整包模式：立即响应
```

### Q5: 如何选择给哪个客户哪种模式？

**决策树**：

```text
是否对初始包体积敏感？
├─ 是 → 网络环境好吗？
│       ├─ 是 → 插件模式 ✅
│       └─ 否 → 整包模式（避免下载体验差）
└─ 否 → 是否需要离线使用？
        ├─ 是 → 整包模式 ✅
        └─ 否 → 两种模式都可以
```

---

## 九、总结

### 核心优势

使用 **Build Variants** 方案在单仓库中同时支持插件模式和整包模式：

✅ **代码复用率高**：核心业务逻辑只写一次  
✅ **维护成本低**：Bug 修复、功能更新只需一次  
✅ **团队协作简单**：所有人在同一代码库工作  
✅ **版本管理清晰**：统一的版本号和发布流程  
✅ **CI/CD 高效**：一次构建产出多个版本  
✅ **灵活交付**：根据客户需求选择合适的版本  

### 实施步骤

```text
1. 架构设计
   └─ 定义统一的模块接口
   └─ 设计加载器抽象层

2. 配置 Build Variants
   └─ 创建 plugin 和 bundle 两个 flavor
   └─ 配置依赖和资源

3. 实现两种加载器
   └─ PluginModeLoader（Shadow 框架）
   └─ BundleModeLoader（直接加载）

4. 业务代码适配
   └─ 使用统一的 ModuleLoader 接口
   └─ 避免直接依赖具体实现

5. 测试和优化
   └─ 两种模式功能一致性测试
   └─ 性能对比和优化

6. CI/CD 配置
   └─ 自动构建两种版本
   └─ 自动化测试和发布
```

### 适用场景

**推荐使用这个方案，如果你的项目：**

- ✅ 有多个客户，需求不同
- ✅ 既要小包体积，又要完整功能
- ✅ 团队规模适中，能维护抽象层
- ✅ 已经使用或计划使用 Shadow 框架

**不推荐使用，如果：**

- ❌ 项目很简单，模块化收益不大
- ❌ 团队太小，无力维护两套构建
- ❌ 所有客户需求完全一致

---
